<?php
/**
 * SessionApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Tequila API
 *
 * The purpose of this documentation is to provide developers an insight of how to interact with Mysterium Node via Tequila API. This should demonstrate all the possible API calls with described parameters and responses.
 *
 * The version of the OpenAPI document: dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SessionApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SessionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'sessionList' => [
            'application/json',
        ],
        'sessionStatsAggregated' => [
            'application/json',
        ],
        'sessionStatsDaily' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation sessionList
     *
     * Returns sessions history
     *
     * @param  int $page_size Number of items per page. (optional, default to 50)
     * @param  int $page Page to filter the items by. (optional, default to 1)
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SessionListResponse|\OpenAPI\Client\Model\APIError|\OpenAPI\Client\Model\APIError
     */
    public function sessionList($page_size = 50, $page = 1, $date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionList'][0])
    {
        list($response) = $this->sessionListWithHttpInfo($page_size, $page, $date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);
        return $response;
    }

    /**
     * Operation sessionListWithHttpInfo
     *
     * Returns sessions history
     *
     * @param  int $page_size Number of items per page. (optional, default to 50)
     * @param  int $page Page to filter the items by. (optional, default to 1)
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SessionListResponse|\OpenAPI\Client\Model\APIError|\OpenAPI\Client\Model\APIError, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionListWithHttpInfo($page_size = 50, $page = 1, $date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionList'][0])
    {
        $request = $this->sessionListRequest($page_size, $page, $date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SessionListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SessionListResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SessionListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\APIError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\APIError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\APIError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\APIError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\APIError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\APIError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SessionListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SessionListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\APIError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\APIError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sessionListAsync
     *
     * Returns sessions history
     *
     * @param  int $page_size Number of items per page. (optional, default to 50)
     * @param  int $page Page to filter the items by. (optional, default to 1)
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionListAsync($page_size = 50, $page = 1, $date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionList'][0])
    {
        return $this->sessionListAsyncWithHttpInfo($page_size, $page, $date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionListAsyncWithHttpInfo
     *
     * Returns sessions history
     *
     * @param  int $page_size Number of items per page. (optional, default to 50)
     * @param  int $page Page to filter the items by. (optional, default to 1)
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionListAsyncWithHttpInfo($page_size = 50, $page = 1, $date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SessionListResponse';
        $request = $this->sessionListRequest($page_size, $page, $date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionList'
     *
     * @param  int $page_size Number of items per page. (optional, default to 50)
     * @param  int $page Page to filter the items by. (optional, default to 1)
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sessionListRequest($page_size = 50, $page = 1, $date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionList'][0])
    {












        $resourcePath = '/sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'date_from', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'date_to', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $consumer_id,
            'consumer_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hermes_id,
            'hermes_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_type,
            'service_type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionStatsAggregated
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsAggregated'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SessionStatsAggregatedResponse|\OpenAPI\Client\Model\APIError|\OpenAPI\Client\Model\APIError
     */
    public function sessionStatsAggregated($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsAggregated'][0])
    {
        list($response) = $this->sessionStatsAggregatedWithHttpInfo($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);
        return $response;
    }

    /**
     * Operation sessionStatsAggregatedWithHttpInfo
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsAggregated'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SessionStatsAggregatedResponse|\OpenAPI\Client\Model\APIError|\OpenAPI\Client\Model\APIError, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionStatsAggregatedWithHttpInfo($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsAggregated'][0])
    {
        $request = $this->sessionStatsAggregatedRequest($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SessionStatsAggregatedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SessionStatsAggregatedResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SessionStatsAggregatedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\APIError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\APIError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\APIError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\APIError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\APIError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\APIError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SessionStatsAggregatedResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SessionStatsAggregatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\APIError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\APIError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sessionStatsAggregatedAsync
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsAggregated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionStatsAggregatedAsync($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsAggregated'][0])
    {
        return $this->sessionStatsAggregatedAsyncWithHttpInfo($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionStatsAggregatedAsyncWithHttpInfo
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsAggregated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionStatsAggregatedAsyncWithHttpInfo($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsAggregated'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SessionStatsAggregatedResponse';
        $request = $this->sessionStatsAggregatedRequest($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionStatsAggregated'
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsAggregated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sessionStatsAggregatedRequest($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsAggregated'][0])
    {










        $resourcePath = '/sessions/stats-aggregated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'date_from', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'date_to', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $consumer_id,
            'consumer_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hermes_id,
            'hermes_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_type,
            'service_type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionStatsDaily
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsDaily'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SessionStatsDTO|\OpenAPI\Client\Model\APIError|\OpenAPI\Client\Model\APIError
     */
    public function sessionStatsDaily($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsDaily'][0])
    {
        list($response) = $this->sessionStatsDailyWithHttpInfo($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);
        return $response;
    }

    /**
     * Operation sessionStatsDailyWithHttpInfo
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsDaily'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SessionStatsDTO|\OpenAPI\Client\Model\APIError|\OpenAPI\Client\Model\APIError, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionStatsDailyWithHttpInfo($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsDaily'][0])
    {
        $request = $this->sessionStatsDailyRequest($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SessionStatsDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SessionStatsDTO' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SessionStatsDTO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\APIError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\APIError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\APIError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\APIError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\APIError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\APIError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SessionStatsDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SessionStatsDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\APIError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\APIError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sessionStatsDailyAsync
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsDaily'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionStatsDailyAsync($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsDaily'][0])
    {
        return $this->sessionStatsDailyAsyncWithHttpInfo($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionStatsDailyAsyncWithHttpInfo
     *
     * Returns sessions stats
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsDaily'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionStatsDailyAsyncWithHttpInfo($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsDaily'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SessionStatsDTO';
        $request = $this->sessionStatsDailyRequest($date_from, $date_to, $direction, $consumer_id, $hermes_id, $provider_id, $service_type, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionStatsDaily'
     *
     * @param  \DateTime $date_from Filter the sessions from this date. Formatted in RFC3339 e.g. 2020-07-01. (optional)
     * @param  \DateTime $date_to Filter the sessions until this date. Formatted in RFC3339 e.g. 2020-07-30. (optional)
     * @param  string $direction Direction to filter the sessions by. Possible values are \&quot;Provided\&quot;, \&quot;Consumed\&quot;. (optional)
     * @param  string $consumer_id Consumer identity to filter the sessions by. (optional)
     * @param  string $hermes_id Hermes ID to filter the sessions by. (optional)
     * @param  string $provider_id Provider identity to filter the sessions by. (optional)
     * @param  string $service_type Service type to filter the sessions by. (optional)
     * @param  string $status Status to filter the sessions by. Possible values are \&quot;New\&quot;, \&quot;Completed\&quot;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sessionStatsDaily'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sessionStatsDailyRequest($date_from = null, $date_to = null, $direction = null, $consumer_id = null, $hermes_id = null, $provider_id = null, $service_type = null, $status = null, string $contentType = self::contentTypes['sessionStatsDaily'][0])
    {










        $resourcePath = '/sessions/stats-daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'date_from', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'date_to', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $consumer_id,
            'consumer_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hermes_id,
            'hermes_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'provider_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $service_type,
            'service_type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
